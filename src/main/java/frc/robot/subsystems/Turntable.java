package frc.robot.subsystems;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.controller.PIDController;
import edu.wpi.first.wpilibj2.command.PIDSubsystem;
import edu.wpi.first.wpiutil.math.MathUtil;
import frc.robot.Constants;
import frc.robot.Robot;


public class Turntable extends PIDSubsystem {
    // turntable motor
    private WPI_TalonSRX tableMotor = new WPI_TalonSRX(Constants.Turntable.MotorID);

    // Current setpoint
    private int currentSetpoint;

    private DigitalInput limitSwitch = new DigitalInput(Constants.Turntable.LimitSwitch);

    private boolean isHoming = false;
    private boolean isHomed = true; //! Switch back

    /**
     * Turntable constructor
     */
    public Turntable() {
        // Set our PID values
        super(new PIDController(Constants.Turntable.kP, Constants.Turntable.kI, Constants.Turntable.kD));

        // Set the tolerance
        getController().setTolerance(Constants.Turntable.tolerance);

        // Encoder
        tableMotor.setSelectedSensorPosition(0);
    }

    /**
     * turnToAngle
     * @param angle angle to turn to (in degrees)
     */
    public void turnToAngle(double angle) {
        Robot.logger.logln(angle);
        this.currentSetpoint = (int)((16384/360)*angle);
        setSetpoint(this.currentSetpoint);
        getController().setSetpoint(this.currentSetpoint);
    }

    /**
     * atTarget
     * @return whether we are at target
     */
    public boolean atTarget() {
        boolean r = (this.currentSetpoint-5<getMeasurement() && this.currentSetpoint+5>getMeasurement());
        if (r) {
            disable();
            tableMotor.set(0);
        }
        return r;
    }

    /**
     * Use the output generated by the PID
     */
    @Override
    public void useOutput(double output, double setpoint) {
        // Debugging logs
        System.out.println("CurrentPos: " + getMeasurement());
        System.out.println("Wanted: " + this.currentSetpoint);
        System.out.println("OUTPUT: " +  output);

        // Output
        // if (!this.isHoming && this.isHomed) {
        tableMotor.set(MathUtil.clamp(output,-Constants.Turntable.speed,Constants.Turntable.speed));
        // } else {
        //     if (this.isHoming) {
        //         System.out.println(this.limitSwitch.get());
        //         if (this.limitSwitch.get()) {
        //             System.out.println("Homed");
        //             this.tableMotor.pidWrite(0);
        //             this.tableMotor.setSelectedSensorPosition(0);
        //             this.isHomed = true;
        //             this.isHoming = false;
        //         } else {
        //             System.out.println("Homing");
        //             this.tableMotor.pidWrite(-1);
        //         }
        //     }
        // }
    }

    /**
     * Get the encoder position
     */
    @Override
    public double getMeasurement() {
        return tableMotor.getSelectedSensorPosition();
    }

    public void turntablePeriodic() {
        System.out.println(getMeasurement());
    }

    /**
     * Home the turntable
     */
    public void home() {
        System.out.println("Starting homing..");
        this.enable();
        this.isHoming = true;
    }
}
